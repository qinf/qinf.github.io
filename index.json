[{"categories":["Test"],"content":"这周看到来一篇文章Mocking is an Anti-Pattern，这里的观点引起了我的共鸣，工作中确实体会到过Mock带来的坏处或者说是不好的实践。 ","date":"2024-07-20","objectID":"/posts/a12006b/:0:0","tags":["Test"],"title":"Mocking 是一种反模式","uri":"/posts/a12006b/"},{"categories":["Test"],"content":"什么是Mock，什么是反模式 在面向对象程序设计中，模拟对象（英语：mock object，也译作模仿对象）是以可控的方式模拟真实对象行为的假的对象。程序员通常创造模拟对象来测试其他对象的行为，很类似汽车设计者使用碰撞测试假人来模拟车辆碰撞中人的动态行为。 在软件工程中，反面模式（anti-pattern或antipattern）指的是在实践中经常出现但又低效或是有待优化的设计模式[1][2]，是用来解决问题的带有共同性的不良方法。它们已经经过研究并分类，以防止日后重蹈覆辙，并能在研发尚未投产的系统时辨认出来。 在代码测试中，有些有副作用的逻辑无法直接调用的时候Mock就上场了。Mock模拟了代码里面的参数传递、函数调用以及我们预期结果的验证。一切好像极其的合理，代码的执行也跟我们假想的一模一样。 ","date":"2024-07-20","objectID":"/posts/a12006b/:1:0","tags":["Test"],"title":"Mocking 是一种反模式","uri":"/posts/a12006b/"},{"categories":["Test"],"content":"Mock带来哪些坏处 但是就如Mocking is an Anti-Pattern这篇文章所说的“Mocking frameworks are a path to insanity!”，在实践中我们总是代码的happy path进行建模，虽然这是必须的但是无助于我们发现代码中的错误。 过多的Mock导致了很多浪费体力、时间的无效工作。这让我想起了多年前我还在字节工作的时候的一次实践：为了提高代码测试覆盖率编写了大量的Mock，因为很多涉及到IO代码无法直接调用。 Mock IO操作的可能会让忽略很多case，包括：边缘情况、故障等等。 ","date":"2024-07-20","objectID":"/posts/a12006b/:2:0","tags":["Test"],"title":"Mocking 是一种反模式","uri":"/posts/a12006b/"},{"categories":["Test"],"content":"除了Mock我们可以怎么做 那么除了Mock外还有哪些手段可以改进这种情况呢？文中提到了好几种方式。 ","date":"2024-07-20","objectID":"/posts/a12006b/:3:0","tags":["Test"],"title":"Mocking 是一种反模式","uri":"/posts/a12006b/"},{"categories":["Test"],"content":"做更多的单元测试 使用Decompose Conditional和Introduce parameter Object等手段进行重构来方便做单元测试。 这两个都是《重构》这本书中提到的手段。 // Decompose Conditional // before refactor if (!aDate.isBefore(plan.summerStart) \u0026\u0026 !aDate.isAfter(plan.summerEnd)) charge = quantity * plan.summerRate; else charge = quantity * plan.regularRate + plan.regularServiceCharge; // after refactor if (summer()) charge = summerCharge(); else charge = regularCharge(); // Introduce Parameter Object // before refactor function amountInvoiced(startDate, endDate) {...} function amountReceived(startDate, endDate) {...} function amountOverdue(startDate, endDate) {...} // after refactor function amountInvoiced(aDateRange) {...} function amountReceived(aDateRange) {...} function amountOverdue(aDateRange) {...} ","date":"2024-07-20","objectID":"/posts/a12006b/:3:1","tags":["Test"],"title":"Mocking 是一种反模式","uri":"/posts/a12006b/"},{"categories":["Test"],"content":"更易于测试的IO 使用内存数据库替代生产环境数据库进行测试。 使用虚拟文件系统(in memory)模拟文件操作。这里需要考虑接口的设计不要使用文件名作为参数，而应该使用Reader(golang)或者IOStream(Java)这种抽象接口或者实现。 ","date":"2024-07-20","objectID":"/posts/a12006b/:3:2","tags":["Test"],"title":"Mocking 是一种反模式","uri":"/posts/a12006b/"},{"categories":["Test"],"content":"做IO测试 那么就用IO做测试吧，现在的IO设备已经很快了。这里提到了使用Postgres的复制测试数据库的功能可以方便进行测试。 ","date":"2024-07-20","objectID":"/posts/a12006b/:3:3","tags":["Test"],"title":"Mocking 是一种反模式","uri":"/posts/a12006b/"},{"categories":["Test"],"content":"逻辑和服务/IO分离 将业务逻辑和服务/IO分离开，这里业务逻辑就可以进行单独的测试了。对于IO骨架可以使用Command pattern进行测试。 ","date":"2024-07-20","objectID":"/posts/a12006b/:3:4","tags":["Test"],"title":"Mocking 是一种反模式","uri":"/posts/a12006b/"},{"categories":["Test"],"content":"E2E集成测试 基于UI的集成测试是有必要的，但是UI驱动测试比较脆弱，而且很不容易维护。所以可以考虑编写更多的后端E2E的集成测试。 原文里面提供了比较详细的例子来辅助说明各种方式，可以作为参考。 Mock在日常的开发中还是比较经常使用的，比如Flink里面很多测试都单独编写了单独的Mock Object来方便进行测试，在日常的开发中我们可以进行参考。等之后积累的更多的案例可以再完善一下本文。 ","date":"2024-07-20","objectID":"/posts/a12006b/:3:5","tags":["Test"],"title":"Mocking 是一种反模式","uri":"/posts/a12006b/"},{"categories":["TIL"],"content":"Java 多版本管理 sdkman可安装多版本JAVA或者其他软件。sdkman.io jEVN是一个命令行工具让你免于设置JAVA_HOME配置。可以参考这篇文章Configuring jenv the right way # 添加配置到.zshrc，如果使用bash的话需要添加到.bash_profile里面 echo 'export PATH=\"$HOME/.jenv/bin:$PATH\"' \u003e\u003e ~/.zshrc echo 'eval \"$(jenv init -)\"' \u003e\u003e ~/.zshrc # 添加jdk，这里以Mac OSX为例 jenv add /Library/Java/JavaVirtualMachines/jdk-10.0.1.jdk/Contents/Home # 启用全局JAVA version jenv global ${JAVA_VERSION} # 设置SHELL指定的JAVA version jenv shell ${JAVA_VERSION} # 如果使用maven则还需要如下的配置 jenv enable-plugin maven jenv enable-plugin export # 如果不开启的话 $JAVA_HOME 可能为空 ","date":"2022-07-23","objectID":"/posts/java%E5%A4%9A%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86-maven%E5%8D%95%E6%B5%8B/:1:0","tags":["Java","Maven"],"title":"Java多版本管理,Maven单测","uri":"/posts/java%E5%A4%9A%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86-maven%E5%8D%95%E6%B5%8B/"},{"categories":["TIL"],"content":"Java 单测时出现 java.net.MalformedURLException: unknown protocol: socks5 异常 在跑Flink Kubernetes模块的单测时遇到此异常，完整异常栈 io.fabric8.kubernetes.client.KubernetesClientException: Invalid proxy server configuration at io.fabric8.kubernetes.client.utils.HttpClientUtils.createHttpClient(HttpClientUtils.java:158) at io.fabric8.kubernetes.client.utils.HttpClientUtils.createHttpClientForMockServer(HttpClientUtils.java:66) at io.fabric8.kubernetes.client.server.mock.KubernetesMockServer.createClient(KubernetesMockServer.java:86) at org.apache.flink.kubernetes.MixedKubernetesServer.before(MixedKubernetesServer.java:64) at org.junit.rules.ExternalResource$1.evaluate(ExternalResource.java:46) at org.junit.rules.ExternalResource$1.evaluate(ExternalResource.java:48) at org.apache.flink.util.TestNameProvider$1.evaluate(TestNameProvider.java:45) at org.junit.rules.TestWatcher$1.evaluate(TestWatcher.java:55) at org.junit.rules.RunRules.evaluate(RunRules.java:20) at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57) at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290) at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71) at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288) at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58) at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268) at org.junit.runners.ParentRunner.run(ParentRunner.java:363) at org.junit.runner.JUnitCore.run(JUnitCore.java:137) at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:69) at com.intellij.rt.junit.IdeaTestRunner$Repeater$1.execute(IdeaTestRunner.java:38) at com.intellij.rt.execution.junit.TestsRepeater.repeat(TestsRepeater.java:11) at com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:35) at com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:235) at com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:54) Caused by: java.net.MalformedURLException: unknown protocol: socks5 at java.net.URL.\u003cinit\u003e(URL.java:617) at java.net.URL.\u003cinit\u003e(URL.java:507) at java.net.URL.\u003cinit\u003e(URL.java:456) at io.fabric8.kubernetes.client.utils.HttpClientUtils.getProxyUrl(HttpClientUtils.java:221) at io.fabric8.kubernetes.client.utils.HttpClientUtils.createHttpClient(HttpClientUtils.java:144) ... 24 more 此异常是由于设置的代理导致的，可以参考Security Exception: MalformedURLException: unknown protocol: socket during opening JNLP file修改网络设置。但是只修改这里对于我的环境是没有生效的，因为在公司需要配置代理，设置了HTTPS_PROXY=socket5://127.0.0.1:port所以提示unknown protocol: socks5，需要在终端中执行unset HTTPS_PROXY，然后执行单测就可以了。 ","date":"2022-07-23","objectID":"/posts/java%E5%A4%9A%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86-maven%E5%8D%95%E6%B5%8B/:2:0","tags":["Java","Maven"],"title":"Java多版本管理,Maven单测","uri":"/posts/java%E5%A4%9A%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86-maven%E5%8D%95%E6%B5%8B/"},{"categories":["TIL"],"content":"Maven 单测使用 由于很少使用maven命令做测试，这次处理上面一个问题时候用到了，这里简单整理一下maven test相关的使用命令。 # 执行单个类的测试 maven test -Dtest=com.my.pkg.FarTest # 执行单个类的指定方法测试 maven test -Dtest=com.my.pkg.FarTest#testFunc # 跳过测试 maven clean package -DskipTests # 跳过测试及测试编译 mvn package -Dmaven.test.skip=true ","date":"2022-07-23","objectID":"/posts/java%E5%A4%9A%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86-maven%E5%8D%95%E6%B5%8B/:3:0","tags":["Java","Maven"],"title":"Java多版本管理,Maven单测","uri":"/posts/java%E5%A4%9A%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86-maven%E5%8D%95%E6%B5%8B/"},{"categories":["TIL"],"content":"启动自动挂载硬盘 # 查看磁盘分区 sudo fdisk -l # 挂载磁盘 sudo mount /dev/sdb /data/ # 查看磁盘挂载UUID sudo blkid /dev/sdb # 修改/etc/fstab文件 sudo vi /etc/fstab # 添加磁盘信息，[UUID=************] [挂载磁盘分区] [挂载磁盘格式] 0 2 # 第一数字0，0是开机不检查磁盘，1是开机检查磁盘 # 第二个数2，0表示交换分区，1表示启动分区，2表示普通分区 UUID=${UUID} /media/qinf/D ntfs defaults 0 2 ","date":"2022-05-09","objectID":"/posts/ubuntu%E5%90%AF%E5%8A%A8%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BD%E7%A1%AC%E7%9B%98/:1:0","tags":["Ubuntu","Docker"],"title":"Ubuntu启动自动挂载硬盘","uri":"/posts/ubuntu%E5%90%AF%E5%8A%A8%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BD%E7%A1%AC%E7%9B%98/"},{"categories":["TIL"],"content":"Docker container 启动重启 docker run --restart=always -d --name ${container_name} -p ${port}:80 -v /localdir:/mount_dir ${image_name} ","date":"2022-05-09","objectID":"/posts/ubuntu%E5%90%AF%E5%8A%A8%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BD%E7%A1%AC%E7%9B%98/:2:0","tags":["Ubuntu","Docker"],"title":"Ubuntu启动自动挂载硬盘","uri":"/posts/ubuntu%E5%90%AF%E5%8A%A8%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BD%E7%A1%AC%E7%9B%98/"},{"categories":["TIL"],"content":"ping使用的是ICMP协议，不支持代理。 可以执行curl -vv https://www.google.com看看有没有走代理。 ","date":"2022-05-06","objectID":"/posts/ping%E4%B8%8D%E8%B5%B0%E4%BB%A3%E7%90%86/:0:0","tags":["proxy"],"title":"Ping不走代理","uri":"/posts/ping%E4%B8%8D%E8%B5%B0%E4%BB%A3%E7%90%86/"}]
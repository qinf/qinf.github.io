[{"categories":["troubleshooting"],"content":" 你是不是遇到过这样的问题：自己的一个服务一直稳定运行的挺长时间了，突然它的行为就不符合预期了。然后你的同事来找你看看为啥行为变了呢？我最近也遇到了一个类似的问题，这里就简单记录一下自己排查这个问题的过程。 服务描述 这里的用户通过Rest API 访问service-1的function1，function1通过Rest API访问service-2的function2，function2计算出结果之后返回给调用方。这里service-2``function2就是我上线挺长时间的一个功能。简化java class和方法的定义如下，另外说明一下这里function1实际里面有很多方法调用，这里全部简化掉只是为了说明相关的排查方法。 // function1 package com.eason.service1; class Service1() { public List\u003cResult\u003e function1(String params); } // function2 package com.eason.service2; class Service2() { public List\u003cResult\u003e function2(String params); } 这里遇到的问题就是用户之前可以拿到结果，现在没有结果了。 问题排查 首先直接调用service-2``function2的Rest API发现其功能是正常的，那么排除function2是不可用的。 然后怀疑是function1调用function2的时候出现了问题。那么如何排查调用是真的有问题呢？如果有日志记录调用过程，那么排查会方便一些，但是不是所有的调用都会记录日志的，否则日志量可能太大了。 接下来就寄出了本次排查问题的利器：Arthas。这里排查的基本思路就是中function1和function2上分别监控调用的入参、返回值和预期的值进行对比。下面就整理一些具体的步骤。 当然首先要做的肯定是下载并解压arthas-bin.zip，可以去Arthas在Github[1]仓库进行下载。这里面包含多个jar和相关的脚本。具体使用可以参加其文档。 我通常习惯使用java -jar arthas-boot.jar启动arthas server，这里需要：需要使用和服务相同的账户和Java版本。 然后我们通过数字选择对应的服务，上面的命令会有类似jps的输出，每个Java服务都会列出来，选择我们的目标服务即可 使用watch[2]命令来观察函数的入参、返回值 watch com.eason.service1.Service1 function1 \"{params,target,returnObj}\" -x 4 -b -n 5 \"{parama,returnObj}\"为观察表达式 -x指定输出结果属性的便利深度，就是将输出结果以可读的方式展示 -b在函数调用前观察，当然也有-e在函数调用之后观察 -n这里是执行几次 watch com.eason.service1.Service2 function2 \"{params,target,returnObj}\" -x 4 -b -n 5 通过4的结果发现，function1调用function2的参数传的不符合预期，又对function1内部的其他相关的方法做了watch，最终定位到了问题。` Arthas有非常多的功能，可以通过命令列表看到其支持的功能[3]，常用的有watch、heapdump、profiler、trace等。熟悉这些命令的基本使用非常有利于线上问题的排查。 当然线上服务的问题多种多样，Arthas只是排查问题的一个工具。如果服务是分布式的且有很多实例，那么文中这种排查方式处理起来就有些麻烦了，在多个实例上执行这套流程是比较耗时的，可能需要更都工具化的东西来支持。 参考 [1] https://github.com/alibaba/arthas/releases [2] https://arthas.aliyun.com/doc/watch.html [3] https://arthas.aliyun.com/doc/commands.html ","date":"2024-07-23","objectID":"/posts/729576f/:0:0","tags":["troubleshooting","Arthas"],"title":"我的线上服务行为又不符合预期了","uri":"/posts/729576f/"},{"categories":["Test"],"content":"这周看到来一篇文章Mocking is an Anti-Pattern，这里的观点引起了我的共鸣，工作中确实体会到过Mock带来的坏处或者说是不好的实践。 什么是Mock，什么是反模式 在面向对象程序设计中，模拟对象（英语：mock object，也译作模仿对象）是以可控的方式模拟真实对象行为的假的对象。程序员通常创造模拟对象来测试其他对象的行为，很类似汽车设计者使用碰撞测试假人来模拟车辆碰撞中人的动态行为。 在软件工程中，反面模式（anti-pattern或antipattern）指的是在实践中经常出现但又低效或是有待优化的设计模式[1][2]，是用来解决问题的带有共同性的不良方法。它们已经经过研究并分类，以防止日后重蹈覆辙，并能在研发尚未投产的系统时辨认出来。 在代码测试中，有些有副作用的逻辑无法直接调用的时候Mock就上场了。Mock模拟了代码里面的参数传递、函数调用以及我们预期结果的验证。一切好像极其的合理，代码的执行也跟我们假想的一模一样。 Mock带来哪些坏处 但是就如Mocking is an Anti-Pattern这篇文章所说的“Mocking frameworks are a path to insanity!”，在实践中我们总是代码的happy path进行建模，虽然这是必须的但是无助于我们发现代码中的错误。 过多的Mock导致了很多浪费体力、时间的无效工作。这让我想起了多年前我还在字节工作的时候的一次实践：为了提高代码测试覆盖率编写了大量的Mock，因为很多涉及到IO代码无法直接调用。 Mock IO操作的可能会让忽略很多case，包括：边缘情况、故障等等。 除了Mock我们可以怎么做 那么除了Mock外还有哪些手段可以改进这种情况呢？文中提到了好几种方式。 做更多的单元测试 使用Decompose Conditional和Introduce parameter Object等手段进行重构来方便做单元测试。 这两个都是《重构》这本书中提到的手段。 // Decompose Conditional // before refactor if (!aDate.isBefore(plan.summerStart) \u0026\u0026 !aDate.isAfter(plan.summerEnd)) charge = quantity * plan.summerRate; else charge = quantity * plan.regularRate + plan.regularServiceCharge; // after refactor if (summer()) charge = summerCharge(); else charge = regularCharge(); // Introduce Parameter Object // before refactor function amountInvoiced(startDate, endDate) {...} function amountReceived(startDate, endDate) {...} function amountOverdue(startDate, endDate) {...} // after refactor function amountInvoiced(aDateRange) {...} function amountReceived(aDateRange) {...} function amountOverdue(aDateRange) {...} 更易于测试的IO 使用内存数据库替代生产环境数据库进行测试。 使用虚拟文件系统(in memory)模拟文件操作。这里需要考虑接口的设计不要使用文件名作为参数，而应该使用Reader(golang)或者IOStream(Java)这种抽象接口或者实现。 做IO测试 那么就用IO做测试吧，现在的IO设备已经很快了。这里提到了使用Postgres的复制测试数据库的功能可以方便进行测试。 逻辑和服务/IO分离 将业务逻辑和服务/IO分离开，这里业务逻辑就可以进行单独的测试了。对于IO骨架可以使用Command pattern进行测试。 E2E集成测试 基于UI的集成测试是有必要的，但是UI驱动测试比较脆弱，而且很不容易维护。所以可以考虑编写更多的后端E2E的集成测试。 原文里面提供了比较详细的例子来辅助说明各种方式，可以作为参考。 Mock在日常的开发中还是比较经常使用的，比如Flink里面很多测试都单独编写了单独的Mock Object来方便进行测试，在日常的开发中我们可以进行参考。等之后积累的更多的案例可以再完善一下本文。 ","date":"2024-07-20","objectID":"/posts/a12006b/:0:0","tags":["Test"],"title":"Mocking 是一种反模式","uri":"/posts/a12006b/"},{"categories":["TIL"],"content":"Java 多版本管理 sdkman可安装多版本JAVA或者其他软件。sdkman.io jEVN是一个命令行工具让你免于设置JAVA_HOME配置。可以参考这篇文章Configuring jenv the right way # 添加配置到.zshrc，如果使用bash的话需要添加到.bash_profile里面 echo 'export PATH=\"$HOME/.jenv/bin:$PATH\"' \u003e\u003e ~/.zshrc echo 'eval \"$(jenv init -)\"' \u003e\u003e ~/.zshrc # 添加jdk，这里以Mac OSX为例 jenv add /Library/Java/JavaVirtualMachines/jdk-10.0.1.jdk/Contents/Home # 启用全局JAVA version jenv global ${JAVA_VERSION} # 设置SHELL指定的JAVA version jenv shell ${JAVA_VERSION} # 如果使用maven则还需要如下的配置 jenv enable-plugin maven jenv enable-plugin export # 如果不开启的话 $JAVA_HOME 可能为空 Java 单测时出现 java.net.MalformedURLException: unknown protocol: socks5 异常 在跑Flink Kubernetes模块的单测时遇到此异常，完整异常栈 io.fabric8.kubernetes.client.KubernetesClientException: Invalid proxy server configuration at io.fabric8.kubernetes.client.utils.HttpClientUtils.createHttpClient(HttpClientUtils.java:158) at io.fabric8.kubernetes.client.utils.HttpClientUtils.createHttpClientForMockServer(HttpClientUtils.java:66) at io.fabric8.kubernetes.client.server.mock.KubernetesMockServer.createClient(KubernetesMockServer.java:86) at org.apache.flink.kubernetes.MixedKubernetesServer.before(MixedKubernetesServer.java:64) at org.junit.rules.ExternalResource$1.evaluate(ExternalResource.java:46) at org.junit.rules.ExternalResource$1.evaluate(ExternalResource.java:48) at org.apache.flink.util.TestNameProvider$1.evaluate(TestNameProvider.java:45) at org.junit.rules.TestWatcher$1.evaluate(TestWatcher.java:55) at org.junit.rules.RunRules.evaluate(RunRules.java:20) at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57) at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290) at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71) at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288) at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58) at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268) at org.junit.runners.ParentRunner.run(ParentRunner.java:363) at org.junit.runner.JUnitCore.run(JUnitCore.java:137) at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:69) at com.intellij.rt.junit.IdeaTestRunner$Repeater$1.execute(IdeaTestRunner.java:38) at com.intellij.rt.execution.junit.TestsRepeater.repeat(TestsRepeater.java:11) at com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:35) at com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:235) at com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:54) Caused by: java.net.MalformedURLException: unknown protocol: socks5 at java.net.URL.\u003cinit\u003e(URL.java:617) at java.net.URL.\u003cinit\u003e(URL.java:507) at java.net.URL.\u003cinit\u003e(URL.java:456) at io.fabric8.kubernetes.client.utils.HttpClientUtils.getProxyUrl(HttpClientUtils.java:221) at io.fabric8.kubernetes.client.utils.HttpClientUtils.createHttpClient(HttpClientUtils.java:144) ... 24 more 此异常是由于设置的代理导致的，可以参考Security Exception: MalformedURLException: unknown protocol: socket during opening JNLP file修改网络设置。但是只修改这里对于我的环境是没有生效的，因为在公司需要配置代理，设置了HTTPS_PROXY=socket5://127.0.0.1:port所以提示unknown protocol: socks5，需要在终端中执行unset HTTPS_PROXY，然后执行单测就可以了。 Maven 单测使用 由于很少使用maven命令做测试，这次处理上面一个问题时候用到了，这里简单整理一下maven test相关的使用命令。 # 执行单个类的测试 maven test -Dtest=com.my.pkg.FarTest # 执行单个类的指定方法测试 maven test -Dtest=com.my.pkg.FarTest#testFunc # 跳过测试 maven clean package -DskipTests # 跳过测试及测试编译 mvn package -Dmaven.test.skip=true ","date":"2022-07-23","objectID":"/posts/java%E5%A4%9A%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86-maven%E5%8D%95%E6%B5%8B/:0:0","tags":["Java","Maven"],"title":"Java多版本管理,Maven单测","uri":"/posts/java%E5%A4%9A%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86-maven%E5%8D%95%E6%B5%8B/"},{"categories":["TIL"],"content":"启动自动挂载硬盘 # 查看磁盘分区 sudo fdisk -l # 挂载磁盘 sudo mount /dev/sdb /data/ # 查看磁盘挂载UUID sudo blkid /dev/sdb # 修改/etc/fstab文件 sudo vi /etc/fstab # 添加磁盘信息，[UUID=************] [挂载磁盘分区] [挂载磁盘格式] 0 2 # 第一数字0，0是开机不检查磁盘，1是开机检查磁盘 # 第二个数2，0表示交换分区，1表示启动分区，2表示普通分区 UUID=${UUID} /media/qinf/D ntfs defaults 0 2 Docker container 启动重启 docker run --restart=always -d --name ${container_name} -p ${port}:80 -v /localdir:/mount_dir ${image_name} ","date":"2022-05-09","objectID":"/posts/ubuntu%E5%90%AF%E5%8A%A8%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BD%E7%A1%AC%E7%9B%98/:0:0","tags":["Ubuntu","Docker"],"title":"Ubuntu启动自动挂载硬盘","uri":"/posts/ubuntu%E5%90%AF%E5%8A%A8%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BD%E7%A1%AC%E7%9B%98/"},{"categories":["TIL"],"content":"ping使用的是ICMP协议，不支持代理。 可以执行curl -vv https://www.google.com看看有没有走代理。 ","date":"2022-05-06","objectID":"/posts/ping%E4%B8%8D%E8%B5%B0%E4%BB%A3%E7%90%86/:0:0","tags":["proxy"],"title":"Ping不走代理","uri":"/posts/ping%E4%B8%8D%E8%B5%B0%E4%BB%A3%E7%90%86/"}]